<html>

<head>
	<meta charset="UTF-8">

	<script src="d3.v5.min.js"></script>

	<style>

	svg {
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
               background: #FFFFFA;
         border: 1px solid gray;
         border-radius: 7px;
	}

   .base {
      fill: #fff;
   }

   #header {
      height:30px;
   }

   #container {

      display:table;
      width: 100%;
      height:90%;
      text-align: center;

    }

   #Chart {
      display: table-cell;
      vertical-align:middle;
   }

path {
   stroke-width: 1;
   stroke: #999;
}

.node-link {
   stroke-width: 2;
   stroke: #999;
   stroke-linecap: round;
   cursor: pointer;
}



.node {
   cursor: pointer;
}



text {
   font-size: 9pt;
  
   fill: #eee;
   stroke-dasharray: none;
   text-anchor: middle;
}


#graph-tooltip {
   position: absolute;
   width: auto;
   height: auto;
   padding: 5px;
   font: 12px sans-serif;
   background: white;
   border: 1px solid gray;
   border-radius: 7px;
   pointer-events: none;
   z-index: 100;
   opacity: 0;
}

.hidden {
	display : none;
}

.node-shape {
	fill: #FDFDFD;
   stroke-width:1;
   stroke: #999;
}

.node-shape.selected {
   cursor: pointer;
   	stroke: #999;
   	stroke-width: 1;
	stroke-dasharray: 4,1;
}


.node-shape.mouseOver {
	stroke-width: 4;
	stroke: #999;
}

   </style>

   <script>



   const levels = [ "Organization", "Team", "Employee" ];


   class Graph {

      constructor(data, target) {
         this.loadData( data )
         this.target = target
         this.init()
      }

      init () {
         this.links = []
         this.nodes = []
         this.width = this.options.width || 800
         this.height = this.options.height || 600
         this.maxSize = this.options.maxSize || 40
         this.defaultClr = this.options.defaultClr || "#0000FF"
         this.levelIndex = this.options.initLevel === undefined ? 1 : this.options.initLevel;

         this.tooltipFields = false;

         this.svgInit();
         this.initNodeLinks();
         this.loadLevel();
 
      }


      loadData ( data ) {
         this.data = data || {};
         this.options = data.options || {};
      }


      tooltipFunc(d) {
         if(!this.tooltipFields) return "";         
         return this.tooltipFields.map(dd => {return dd + ' : ' + d[dd] }).join("<br>");
      }

      loadLevel() {
       //  this.initNodeLinks();
         this.currentLevel = levels[this.levelIndex]
         this.currentNodes = this.data[this.currentLevel];
         this.preprocessNodes()
         this.nodesToLinks();
      }


      draw() {

         this.initGraph()
         this.forceLink = d3.forceLink().links(this.links).strength(0.01)
         this.restartGraph( )
      }

      preprocessNodes (path) {
         
         this.nodes = [];
         let index = 0;
         let that = this;
         this.tooltipFields = false;
    
         this.currentNodes.forEach( (d,i) => { 
            if(d.id === undefined) d.id == index++;
            if(d.x === undefined) d.x = this.width/2;
            if(d.y === undefined) d.y = this.height/2;
            this.nodes.push(d);           
            if(d._tooltipFields) {     
               that.tooltipFields = d._tooltipFields;
            }
         })

     //   this.nodes = this.nodes.splice(0,100)
      }

      nodesToLinks ()  {
        var that = this
        this.links =  [];
        var nodesById = {}
        this.nodes.forEach(d => { d.incoming = 0, nodesById[d.id] = d })
        this.nodes.forEach(
            d =>
                d.dependencies &&
                d.dependencies.forEach(id =>
                    nodesById[id]  ? ++nodesById[id].incoming && that.links.push({ id: "link-" + d.id + '-' + id, source: d, target: nodesById[id] }) : console.log('MISSING target node id=' + id)
                )
         )
      }

      initNodeLinks() {

         this.base.html("")

         this.linkBase = this.base
            .append("g")
            .attr("class", "links-group")

         this.nodeBase = this.base
            .append("g")
            .attr("class", "nodes-group")

      }

      calcSize(d) {         
         return this.maxSize; // default
      }

      restartGraph ( path ) {
        var that = this

        this.clink = this.linkBase.selectAll(".node-link-group").data(this.links, d => d.id )

        this.clink
            .exit()
            .remove()

        let clinkEnter = this.clink
            .enter()
            .append("g")
            .attr("class", "node-link-group")

        clinkEnter
            .append("line")
            .attr("class", "node-link")
        //    .attr("id", d => d.id)
            .each(d => d.double = that.links.filter( l => ( l.source === d.target && l.target === d.source) ).length > 0)
            .style("stroke", d =>  d.double ? that.markclr : that.defaultclr )
            .style("marker-end", d =>  d.double ? "url(#end-arrow-double)" : "url(#end-arrow-single)" )

         this.clink.merge(clinkEnter)

        this.node = this.nodeBase.selectAll(".node").data(this.nodes, d => d.id)

        this.node
            .exit()
            .remove()

        let nodeEnter = this.node
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("id", d => "node-" + d.id )
            .each(function(d) {
                let el = d3.select(this),
                  shape;

                switch(d.shape) {
         
                   case 'circle':
                   case 'ellipse':
                   default:
                     shape = el.append("ellipse")
                     .each(function() {
                        let el = d3.select(this),
                           size = that.calcSize(d)
                        el.attr('rx', size)
                           .attr('ry', size)
                           .attr('r', size)
                           d.size = size
                     })
                     break;
                 }

                 el
                  .append('text').text(d.Name)
                  .attr('dy',5)

                 shape
                     .classed("node-shape", true)
                     .style("fill", d =>  d.color || that.defaultClr )
                    .on("mousemove", function(d) {
                        tooltip
                            .style(
                                "left",
                                d3.event.pageX + 20 + "px"
                            )
                            .style(
                                "top",
                                d3.event.pageY  -10 + "px"
                            )

                    })
                    .on("mouseover", function(d) {

                        if(!that.tooltipFields) return;

                        let p = d3.mouse(this)
                        tooltip
                            .html( that.tooltipFunc(d) )
                            .transition()
                            .duration(500)
                            .style("opacity", 1)
                    })
                    .on("mouseout", function(d) {
                        tooltip
                            .transition()
                            .duration(400)
                            .style("opacity", 0)
                    })

            })
            .call(
                d3.drag()
                    .on("start", d => {
                        if (!d3.event.active)
                            that.simulation.alphaTarget(0.01).restart()
                        d.fx = d.x
                        d.fy = d.y
                        d.movable = true
                    })
                    .on("drag", d => {
                        d.fx = d3.event.x
                        d.fy = d3.event.y
                    })
                    .on("end", d => {
                        if (!d3.event.active) that.simulation.alphaTarget(0)
                        d.fx = d.x // null
                        d.fy = d.y // null
                    })
            )

        nodeEnter.merge(this.node)

        this.simulation
         .nodes(this.nodes)
         .force(
                "link",
                this.forceLink
            )
            .velocityDecay(0.9)
             .alphaTarget(0.01)
            .alpha(0.7)
            .restart()
    }


      tooltipText(d) {

         let text = [];
         for(let i in d) {
            text.push ( i + ' : ' + ( d.isInteger ? this.data[i].Name : d ) );
         }
         return text.join('\n')
      }


      ticked() {

         var that = this


      d3.selectAll(".node").attr(
            "transform",
            d => "translate(" +  ( 
            [
               d.x = Math.max(d.size, Math.min(that.width - d.size, d.x)),
               d.y = Math.max(d.size, Math.min(that.height - d.size, d.y))
            ] ) +

               ")"
        )

         d3.selectAll(".node-link-group")

         .each(function(d) {

               var rB1,rB2,rA1,rA2,
                  target = d3.select('#node-'  + d.target.id + " .node-shape"),
                  source = d3.select('#node-'  + d.source.id + " .node-shape")


           

            rB1 =  2+ +source.attr('r')
            rA1 = rB1;

             
            rB2 = 2+ +target.attr('r')
            rA2 = rB2

 


            let deltaX = (d.target.x - d.source.x) || 0.1,
               deltaY = (d.target.y - d.source.y) || 0.1,
               alfa = Math.atan( deltaX / deltaY ),
               dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY) ,
               normX = deltaX / dist,
               normY = deltaY / dist

            let r1 = 1 / Math.sqrt( Math.pow( Math.sin( alfa) / rB1, 2) + Math.pow( Math.cos( alfa) / rA1, 2) ),
               r2 = 1 / Math.sqrt( Math.pow( Math.sin( alfa) / rB2, 2) + Math.pow( Math.cos( alfa) / rA2, 2) ),

               sourcePadding = r1 +2,
               targetPadding = r2 +2,
               sourceX = d.source.x + (sourcePadding * normX),
               sourceY = d.source.y + (sourcePadding * normY),
               targetX = d.target.x - (targetPadding * normX),
               targetY = d.target.y - (targetPadding * normY);

               d3.select(this).select('line')
                  .attr("x1", sourceX)
                  .attr("y1", sourceY)
                  .attr("x2", targetX)
                  .attr("y2", targetY)

         })


      }


      initGraph() {

         var that = this

         this.simulation = d3.forceSimulation()

            .force(
                "collide",
                d3.forceCollide(function(d) { return d.size * 1.5 || 30 })
                .strength(0.2)
            )

            .force("repel",
               d3.forceManyBody().strength(-900).distanceMax(500).distanceMin(60)
               )

            .force(
                "centerX",
                d3.forceX(that.width/2) )


            .force(
                "centerY",
                d3.forceY(that.height /2) )


            .on("tick", this.ticked.bind(this))

     }



      createArrow(id, d, fill) {
         this.svg
            .append("defs")
            .append("marker")
            .attr("id", id)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 6)
            .attr("markerWidth", 4)
            .attr("markerHeight", 4)
            .attr("orient", "auto")
            .append("path")
               .attr("d", d)
               .attr("fill", fill)
      }

      svgInit () {

         this.svg = this.target.selectAll(".svg-area")
            .data([1])
            .enter()
            .append('svg')
               .attr("id", 'svg-area')
               .attr("oncontextmenu", "return false;")
               .attr("width", this.width)
               .attr("height", this.height)
               .attr("preserveAspectRatio", "xMinYMin meet")

         this.createArrow("end-arrow-single", "M0,-5L10,0L0,5", this.defaultClr)
         this.createArrow("start-arrow-single", "M10,-5L0,0L10,5", this.defaultClr)
  
         this.base = this.svg
               .append('g')
               .classed('base', true)

      }

   }



</script>

 </head>

 <body>

<div>Data file: <input  type="text" id="path_text" value="data.json"/> <input id="redraw_b" type="button" value="Load"/></div>

   <div id="container">
      <div id="Chart"></div>
   </div>

   <div id="graph-tooltip"></div>

   <script>

   const tooltip = d3.select("#graph-tooltip");

   d3.json( d3.select("#path_text").property('value') ).then( data => {
      const target = d3.select("#Chart"),
            theGraph = new Graph(data, target)
      theGraph.draw();
  
   });

   </script>

 </body>
 </html>




